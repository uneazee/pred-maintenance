"""
Diagnostic script to check model files integrity
Run this to identify which file is causing the issue
"""

import pickle
from pathlib import Path
import sys

def check_pickle_file(file_path):
    """Try to load a pickle file and report status."""
    try:
        with open(file_path, 'rb') as f:
            # Try to load the file
            obj = pickle.load(f)
        
        # Get object info
        obj_type = type(obj).__name__
        obj_module = type(obj).__module__
        
        print(f"‚úÖ {file_path.name:30s} - OK ({obj_module}.{obj_type})")
        return True
        
    except Exception as e:
        error_type = type(e).__name__
        error_msg = str(e)
        print(f"‚ùå {file_path.name:30s} - ERROR: {error_type}: {error_msg}")
        return False

def main():
    print("=" * 80)
    print("MODEL FILES DIAGNOSTIC CHECK")
    print("=" * 80)
    print()
    
    models_dir = Path('models')
    
    if not models_dir.exists():
        print(f"‚ùå Models directory not found: {models_dir}")
        return
    
    print(f"Checking files in: {models_dir.absolute()}")
    print()
    
    # Files to check
    files_to_check = [
        'model_metadata.pkl',
        'feature_scaler.pkl',
        'random_forest.pkl',
        'gradient_boosting.pkl',
        'svm_rbf.pkl',
        'best_model.pkl'
    ]
    
    results = {}
    
    for filename in files_to_check:
        file_path = models_dir / filename
        
        if not file_path.exists():
            print(f"‚ö†Ô∏è  {filename:30s} - NOT FOUND")
            results[filename] = 'missing'
        else:
            # Check file size
            size = file_path.stat().st_size
            size_mb = size / (1024 * 1024)
            
            print(f"üìÅ {filename:30s} - Size: {size_mb:.2f} MB", end=" ")
            
            # Check if it's too small (likely corrupted)
            if size < 100:
                print(" ‚ö†Ô∏è  VERY SMALL FILE - Likely corrupted")
                results[filename] = 'corrupted_small'
                continue
            
            print()
            
            # Try to load it
            success = check_pickle_file(file_path)
            results[filename] = 'ok' if success else 'corrupted'
    
    # Summary
    print()
    print("=" * 80)
    print("SUMMARY")
    print("=" * 80)
    
    ok_files = [f for f, s in results.items() if s == 'ok']
    corrupted_files = [f for f, s in results.items() if s in ['corrupted', 'corrupted_small']]
    missing_files = [f for f, s in results.items() if s == 'missing']
    
    print(f"‚úÖ OK files: {len(ok_files)}")
    print(f"‚ùå Corrupted files: {len(corrupted_files)}")
    print(f"‚ö†Ô∏è  Missing files: {len(missing_files)}")
    print()
    
    if corrupted_files:
        print("CORRUPTED FILES:")
        for f in corrupted_files:
            print(f"  - {f}")
        print()
        print("SOLUTION:")
        print("  These files need to be regenerated by re-running:")
        print("  python train_model.py")
        print()
    
    if missing_files:
        print("MISSING FILES:")
        for f in missing_files:
            print(f"  - {f}")
        print()
    
    # Check Python and scikit-learn versions
    print("=" * 80)
    print("ENVIRONMENT INFO")
    print("=" * 80)
    print(f"Python version: {sys.version}")
    
    try:
        import sklearn
        print(f"scikit-learn version: {sklearn.__version__}")
    except ImportError:
        print("scikit-learn: NOT INSTALLED")
    
    try:
        import joblib
        print(f"joblib version: {joblib.__version__}")
    except ImportError:
        print("joblib: NOT INSTALLED")
    
    print()
    
    # Version compatibility check
    import sklearn
    sklearn_version = tuple(map(int, sklearn.__version__.split('.')[:2]))
    
    if sklearn_version < (0, 24):
        print("‚ö†Ô∏è  WARNING: Old scikit-learn version detected")
        print("   Consider upgrading: pip install --upgrade scikit-learn")
        print()

if __name__ == '__main__':
    main()
